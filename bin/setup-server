#!/usr/bin/env bash

set -euo pipefail

trap 'echo "An unexpected error occurred. Re-run with --dry-run for a preview." >&2' ERR

# Source functions
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
export SCRIPT_DIR
export PROJECT_ROOT
LIB_DIR="$PROJECT_ROOT/lib"
source "$LIB_DIR/polyfill.functions.bash"
source "$LIB_DIR/logging.functions.bash"
source "$LIB_DIR/security.functions.bash"
source "$LIB_DIR/shared.functions.bash"
source "$LIB_DIR/setup-user.functions.bash"
source "$LIB_DIR/setup-server.functions.bash"

# Argument parsing
usage() { echo "Usage: $0 [--dry-run] [-h|--help]"; }
DRY_RUN=false
while [[ $# -gt 0 ]]; do
    case "$1" in
        --dry-run)
            DRY_RUN=true; shift ;;
        -h|--help)
            usage; exit 0 ;;
        *)
            log_error "Unknown option: $1"
            usage; exit 1 ;;
    esac
done

# Initialize logging
log_init

# Detect current hostname using polyfill function
CURRENT_HOSTNAME="$(get_hostname)"

# Ensure servers root exists
log_subsection "Validation"
SERVERS_ROOT="${SERVERS_ROOT:-$PROJECT_ROOT/servers}"
if [ ! -d "$SERVERS_ROOT" ]; then
    log_error "Servers directory not found: $SERVERS_ROOT"
    exit 1
else
    log_success "Servers directory found"
fi

# Map hostname to server directory (unless SERVER_DIR already set)
if [ -z "${SERVER_DIR:-}" ]; then
    if ! validate_hostname "$CURRENT_HOSTNAME"; then
        log_error "Invalid hostname: $CURRENT_HOSTNAME"
        exit 1
    fi
    MAPPED_DIR="$(map_hostname_to_server_dir "$CURRENT_HOSTNAME")"
    SERVER_DIR="$PROJECT_ROOT/$MAPPED_DIR"
    log_info "Mapped hostname '$CURRENT_HOSTNAME' to server dir: $MAPPED_DIR"
else
    if ! validate_environment_variable "SERVER_DIR" "$SERVER_DIR" "$SERVERS_ROOT"; then
        log_error "Invalid SERVER_DIR environment variable: $SERVER_DIR"
        log_error "SERVER_DIR must be within $SERVERS_ROOT/"
        exit 1
    fi
fi

log_section "Server Setup for $CURRENT_HOSTNAME"
log_info "Using server config from: $SERVER_DIR"

# Check if server directory exists and validate structure
log_subsection "Server Directory Validation"
if [ ! -d "$SERVER_DIR" ]; then
    # Output errors to stderr immediately for test capture
    echo "ERROR: Server directory $SERVER_DIR does not exist" >&2
    echo "ERROR: Create the directory structure with the following commands:" >&2
    echo "ERROR:   mkdir -p $SERVER_DIR" >&2
    echo "ERROR:   touch $SERVER_DIR/packages.yaml" >&2
    echo "ERROR:   mkdir -p $SERVER_DIR/scripts" >&2
    echo "ERROR:" >&2
    echo "ERROR: Then add your server-specific packages to packages.yaml" >&2
    # Also use log_error for consistent formatting in non-test environments
    log_error "Server directory $SERVER_DIR does not exist"
    log_error "Create the directory structure with the following commands:"
    log_error "  mkdir -p $SERVER_DIR"
    log_error "  touch $SERVER_DIR/packages.yaml"
    log_error "  mkdir -p $SERVER_DIR/scripts"
    log_error ""
    log_error "Then add your server-specific packages to packages.yaml"
    exit 1
else
    log_success "Server directory found"
fi

# Validate server directory permissions
if [ ! -r "$SERVER_DIR" ]; then
    # Output error to stderr immediately for test capture
    echo "ERROR: Server directory $SERVER_DIR is not readable" >&2
    echo "ERROR: Check directory permissions with: ls -la $SERVER_DIR" >&2
    # Also use log_error for consistent formatting
    log_error "Server directory $SERVER_DIR is not readable"
    log_error "Check directory permissions with: ls -la $SERVER_DIR"
    exit 1
fi

# Validate servers root directory structure
if [ ! -w "$SERVERS_ROOT" ]; then
    log_warning "Servers root directory $SERVERS_ROOT is not writable"
    log_warning "This may prevent creation of new server directories"
fi

# Validate packages.yaml exists and is safe
PKG_FILE="$SERVER_DIR/packages.yaml"
if [ ! -f "$PKG_FILE" ]; then
    if [ "$DRY_RUN" = true ]; then
        log_info "No packages.yaml found - no packages would be installed"
    else
        log_error "Missing packages.yaml in $SERVER_DIR"
        exit 1
    fi
else
    if ! validate_yaml_file "$PKG_FILE"; then
        log_error "packages.yaml failed validation"
        exit 1
    else
        log_success "packages.yaml validated"
    fi
fi

# Handle shared server configurations first
log_subsection "Shared Server Configuration"
SHARED_SERVER_DIR="$SERVERS_ROOT/shared"
if [ -d "$SHARED_SERVER_DIR" ] && [ "$(ls -A "$SHARED_SERVER_DIR" 2>/dev/null)" ]; then
    log_info "Processing shared server configurations..."
    
    # Handle shared server packages first
    if [ -n "${PLATFORM:-}" ]; then
        PLATFORM="$PLATFORM"
    else
        PLATFORM="$(detect_platform)"
    fi
    
    # Source macOS-specific functions if running on macOS
    if [ "$PLATFORM" = "macos" ]; then
        source "$LIB_DIR/macos.functions.bash"
    fi
    
    # Check if shared packages file exists
    SHARED_PACKAGES_FILE="$SHARED_SERVER_DIR/packages.yaml"
    if [ -f "$SHARED_PACKAGES_FILE" ]; then
        # File exists, so validation failure should exit
        if handle_shared_server_packages "$PLATFORM" "$DRY_RUN"; then
            log_success "Shared server packages processed"
        else
            # Validation failed - this is a critical error, not just "no packages"
            exit 1
        fi
    else
        log_info "No shared server packages found"
    fi
    
    # Process shared custom scripts
    if [ "$DRY_RUN" = true ]; then
        echo "SHARED SERVER CONFIG:"
        log_dry_run "Process shared server custom scripts from $SHARED_SERVER_DIR"
    else
        # Custom scripts will be processed during the regular server package handling
        log_info "Shared server configurations ready"
    fi
else
    log_info "No shared server configurations found"
fi

# Handle package management
log_subsection "Package Management"
if [ -n "${PLATFORM:-}" ]; then
    PLATFORM="$PLATFORM"
else
    PLATFORM="$(detect_platform)"
fi

# Source macOS-specific functions if running on macOS
if [ "$PLATFORM" = "macos" ]; then
    source "$LIB_DIR/macos.functions.bash"
fi
handle_server_packages "$PLATFORM" "$DRY_RUN"

# Final completion handled by log_init trap

exit 0
