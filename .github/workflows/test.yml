name: Test Laingville Scripts

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test-bash:
    name: Bash Tests
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            platform: nix
            runner: ubuntu-latest
          - os: macos-latest
            platform: macos
            runner: macos-latest
          - os: archlinux
            platform: archlinux
            runner: ubuntu-latest
            container: archlinux:latest
    runs-on: ${{ matrix.runner }}
    container: ${{ matrix.container }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install Nix
      if: matrix.platform == 'nix'
      uses: cachix/install-nix-action@v27
      with:
        nix_path: nixpkgs=channel:nixos-25.05



    - name: Cache tools (Arch Linux)
      if: matrix.platform == 'archlinux'
      id: cache-tools-arch
      uses: actions/cache@v4
      with:
        path: |
          ~/.local/bin/shellspec
          ~/.local/bin/shellcheck
          ~/.local/bin/shfmt
          ~/.local/lib/shellspec
        key: tools-archlinux-shfmt-3.8.0-shellcheck-0.10.0-shellspec-v2

    - name: Cache tools (macOS)
      if: matrix.platform == 'macos'
      id: cache-tools-macos
      uses: actions/cache@v4
      with:
        path: |
          ~/.local/bin/shellspec
          ~/.local/bin/shellcheck
          ~/.local/bin/shfmt
          ~/.local/lib/shellspec
        key: tools-macos-shfmt-3.8.0-shellcheck-0.10.0-shellspec-v2

    - name: Install tools (Nix-on-Ubuntu)
      if: matrix.platform == 'nix'
      run: |
        echo "Installing tools via Nix (no caching, run directly from Nix profile)..."
        # Install tools via Nix
        nix profile install github:NixOS/nixpkgs/nixos-25.05#shellcheck
        nix profile install github:NixOS/nixpkgs/nixos-25.05#shfmt
        nix profile install github:NixOS/nixpkgs/nixos-25.05#shellspec
        nix profile install github:NixOS/nixpkgs/nixos-25.05#kcov
        nix profile install github:NixOS/nixpkgs/nixos-25.05#jq

    - name: Install tools (Arch Linux)
      if: matrix.platform == 'archlinux' && steps.cache-tools-arch.outputs.cache-hit != 'true'
      run: |
        mkdir -p ~/.local/bin
        
        # Update package database and install base tools (skip system upgrade for speed)
        pacman -Sy --noconfirm
        pacman -S --noconfirm base-devel git cmake ninja curl wget tar gzip
        
        # Install shellcheck
        cd /tmp
        wget -qO- https://github.com/koalaman/shellcheck/releases/download/v0.10.0/shellcheck-v0.10.0.linux.x86_64.tar.xz | tar -xJ
        mv shellcheck-v0.10.0/shellcheck ~/.local/bin/
        chmod +x ~/.local/bin/shellcheck
        
        # Install shfmt
        wget -qO ~/.local/bin/shfmt https://github.com/mvdan/sh/releases/download/v3.8.0/shfmt_v3.8.0_linux_amd64
        chmod +x ~/.local/bin/shfmt
        
        # Install shellspec
        curl -fsSL https://git.io/shellspec | sh -s -- --yes

    - name: Install tools (macOS)
      if: matrix.platform == 'macos' && steps.cache-tools-macos.outputs.cache-hit != 'true'
      run: |
        mkdir -p ~/.local/bin
        
        # Install shellcheck
        wget -qO- https://github.com/koalaman/shellcheck/releases/download/v0.10.0/shellcheck-v0.10.0.darwin.x86_64.tar.xz | tar -xJ
        mv shellcheck-v0.10.0/shellcheck ~/.local/bin/
        chmod +x ~/.local/bin/shellcheck
        
        # Install shfmt
        wget -qO ~/.local/bin/shfmt https://github.com/mvdan/sh/releases/download/v3.8.0/shfmt_v3.8.0_darwin_amd64
        chmod +x ~/.local/bin/shfmt
        
        # Install shellspec
        curl -fsSL https://git.io/shellspec | sh -s -- --yes
        
    - name: Install system dependencies (Arch Linux)
      if: matrix.platform == 'archlinux'
      run: |
        # Update package database first
        echo "Updating Arch Linux package database..."
        pacman -Sy --noconfirm
        
        # Install system packages that aren't cacheable (always run to ensure availability)
        echo "Installing system dependencies for Arch Linux..."
        pacman -S --noconfirm jq tmux bc kcov || {
          echo "kcov package not available, building from source..."
          pacman -S --noconfirm libcurl-gnutls elfutils binutils
          cd /tmp
          git clone --depth 1 https://github.com/SimonKagstrom/kcov.git
          cd kcov
          mkdir build && cd build
          cmake -G 'Ninja' ..
          ninja
          ninja install
        }

    - name: Install system dependencies (macOS)
      if: matrix.platform == 'macos'
      run: |
        # Install tmux for configuration testing (always install fresh to avoid library issues)
        brew install tmux

    - name: Add tools to PATH
      run: |
        echo "$HOME/.local/bin" >> $GITHUB_PATH
        # Ensure brew-installed tools are in PATH on macOS
        if [ "${{ matrix.platform }}" = "macos" ]; then
          echo "/usr/local/bin" >> $GITHUB_PATH
          echo "/opt/homebrew/bin" >> $GITHUB_PATH
        fi
        # For Nix, add the nix profile bin to PATH
        if [ "${{ matrix.platform }}" = "nix" ]; then
          echo "$HOME/.nix-profile/bin" >> $GITHUB_PATH
        fi
        

    - name: Check formatting
      run: |
        echo "ðŸŽ¨ Checking bash script formatting on ${{ matrix.platform }}..."
        find . -type f \( -name "*.sh" -o -name "*.bash" \) \
          -not -path "./.git/*" \
          -not -path "./dotfiles/*/.*" \
          -exec shfmt -d {} \;
        
    - name: Lint scripts
      run: |
        echo "ðŸ” Linting bash scripts on ${{ matrix.platform }}..."
        find . -type f \( -name "*.sh" -o -name "*.bash" \) \
          -not -path "./.git/*" \
          -not -path "./dotfiles/*/.*" \
          -exec shellcheck {} \;
        shellcheck setup.sh setup-secrets
        
    - name: Run shellspec tests with coverage (Linux)
      if: matrix.platform == 'nix' || matrix.platform == 'archlinux'
      shell: bash
      run: |
        echo "ðŸ§ª Running bash tests with coverage on ${{ matrix.platform }}..."
        # Run tests with kcov coverage (skip coverage on Arch Linux if kcov unavailable)
        if command -v kcov >/dev/null 2>&1; then
          echo "Running with kcov coverage..."
          shellspec --shell bash --kcov --covdir coverage \
            --kcov-options "--include-pattern=$(pwd)/lib/"
        else
          echo "âš ï¸ kcov not available, running tests without coverage..."
          shellspec --shell bash
        fi
      
    - name: Run shellspec tests (macOS)
      if: matrix.platform == 'macos'
      shell: bash
      run: |
        echo "ðŸ§ª Running bash tests on ${{ matrix.platform }}..."
        shellspec --shell bash
      
    - name: Upload bash coverage (Linux)
      if: matrix.platform == 'nix' || matrix.platform == 'archlinux'
      uses: actions/upload-artifact@v4
      with:
        name: bash-coverage-${{ matrix.platform }}
        path: coverage/

    - name: Generate bash coverage summary (Linux)
      if: matrix.platform == 'nix' || matrix.platform == 'archlinux'
      run: |
        echo "ðŸ“Š Generating bash coverage summary..."
        # Find the coverage.json file (could be in merged/ or a subdirectory)
        COVERAGE_JSON=$(find coverage -name "coverage.json" -type f | head -1)
        
        if [ -n "$COVERAGE_JSON" ]; then
          # Extract coverage percentage from kcov JSON report
          COVERAGE=$(jq -r .percent_covered "$COVERAGE_JSON")
          
          echo "Bash Coverage: ${COVERAGE}%" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ“Š **Bash Test Coverage (${{ matrix.platform }})**: ${COVERAGE}%" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Add coverage badge (use shell arithmetic instead of bc)
          if [ "${COVERAGE%.*}" -ge 80 ]; then
            COLOR="brightgreen"
          elif [ "${COVERAGE%.*}" -ge 60 ]; then
            COLOR="yellow"
          else
            COLOR="red"
          fi
          echo "![Coverage](https://img.shields.io/badge/Bash_Coverage-${COVERAGE}%25-${COLOR})" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Add per-file coverage table for lib/*.bash files
          echo "### ðŸ“‹ Coverage by File" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| File | Coverage | Lines | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|------|----------|-------|--------|" >> $GITHUB_STEP_SUMMARY
          
          # Check if files array exists in coverage.json
          if jq -e '.files' "$COVERAGE_JSON" > /dev/null 2>&1; then
            # Parse file coverage data and filter for lib/*.bash files
            jq -r '.files[] | select(.file | test("lib/.*\\.bash$")) | [.file, .percent_covered, (.covered_lines|tostring) + "/" + (.total_lines|tostring)] | @tsv' "$COVERAGE_JSON" | while IFS=$'\t' read -r filepath percent lines; do
              # Extract just the filename from the full path (e.g. /path/to/lib/shared.functions.bash -> shared.functions.bash)
              filename=$(basename "$filepath")
              
              # Determine status emoji based on coverage percentage
              coverage_num=${percent%.*}
              if [ "$coverage_num" -ge 80 ]; then
                status="âœ… Good"
              elif [ "$coverage_num" -ge 60 ]; then
                status="âš ï¸ Fair"
              else
                status="âŒ Low"
              fi
              
              echo "| $filename | ${percent}% | $lines | $status |" >> $GITHUB_STEP_SUMMARY
            done
          else
            # Fallback: if files array doesn't exist, list expected lib/*.bash files with unknown status
            for bashfile in lib/*.bash; do
              if [ -f "$bashfile" ]; then
                display_name=${bashfile#lib/}
                echo "| $display_name | N/A | N/A | â“ No data |" >> $GITHUB_STEP_SUMMARY
              fi
            done
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
        else
          echo "âš ï¸ Coverage JSON file not found" >> $GITHUB_STEP_SUMMARY
        fi
      
    - name: Test dry-run functionality
      shell: bash
      run: |
        echo "ðŸš€ Testing dry-run functionality on ${{ matrix.platform }}..."
        # Test that dry-run works without requiring sudo/pacman
        export DOTFILES_DIR="./dotfiles/mrdavidlaing"
        ./setup.sh user --dry-run
        
        # Mock hostname command for server test to use 'baljeet' which has packages.yaml
        mkdir -p ~/.local/bin
        echo '#!/bin/bash' > ~/.local/bin/hostname
        echo 'echo "baljeet"' >> ~/.local/bin/hostname
        chmod +x ~/.local/bin/hostname
        export PATH="$HOME/.local/bin:$PATH"
        ./setup.sh server --dry-run
        echo "âœ… Dry-run tests passed on ${{ matrix.platform }}"

  test-powershell:
    name: PowerShell Tests
    strategy:
      matrix:
        os: [windows-latest]
        include:
          # Add specific PowerShell versions if needed
          - os: windows-latest
            powershell-version: "latest"
    runs-on: ${{ matrix.os }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup PowerShell modules
      shell: pwsh
      run: |
        Write-Host "ðŸ”§ Setting up PowerShell environment on ${{ matrix.os }}..." -ForegroundColor Cyan
        
        # Install required modules
        $modules = @('Pester', 'PSScriptAnalyzer')
        foreach ($module in $modules) {
          if (-not (Get-Module -ListAvailable -Name $module)) {
            Write-Host "Installing $module..." -ForegroundColor Yellow
            Install-Module -Name $module -Force -SkipPublisherCheck -Scope CurrentUser
          } else {
            Write-Host "$module already installed" -ForegroundColor Green
          }
        }
        
        # Import modules
        Import-Module Pester -Force
        Import-Module PSScriptAnalyzer -Force

    - name: Run PowerShell linting
      shell: pwsh
      run: |
        Write-Host "ðŸ” Running PowerShell linting on ${{ matrix.os }}..." -ForegroundColor Cyan
        .\scripts\lint-powershell.ps1

    - name: Run Pester tests with coverage
      shell: pwsh
      run: |
        Write-Host "ðŸ§ª Running PowerShell tests with coverage on ${{ matrix.os }}..." -ForegroundColor Cyan
        
        # Configure Pester using the .pester.ps1 file
        $config = Import-PowerShellDataFile '.\.pester.ps1'
        $result = Invoke-Pester -Configuration $config
        
        # Generate coverage summary for GitHub
        if ($result.CodeCoverage) {
          $coverage = $result.CodeCoverage
          $coveragePercent = [math]::Round(($coverage.CoveragePercent), 2)
          
          Write-Host "ðŸ“Š PowerShell Coverage: $coveragePercent%" -ForegroundColor Cyan
          
          # Add to GitHub Step Summary
          "## ðŸ“Š PowerShell Test Results" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append
          "" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append
          "**Coverage**: $coveragePercent%" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append
          "**Tests Passed**: $($result.PassedCount)" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append
          "**Tests Failed**: $($result.FailedCount)" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append
          "**Tests Skipped**: $($result.SkippedCount)" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append
          "" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append
          "### Coverage Details" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append
          "- **Lines Covered**: $($coverage.NumberOfCommandsExecuted) / $($coverage.NumberOfCommandsAnalyzed)" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append
          "- **Files Analyzed**: $($coverage.AnalyzedFiles.Count)" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append
          "" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append
          "### Coverage Badge" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append
          
          # Determine badge color based on coverage
          if ($coveragePercent -ge 80) { $color = "brightgreen" }
          elseif ($coveragePercent -ge 60) { $color = "yellow" }
          else { $color = "red" }
          
          "![Coverage](https://img.shields.io/badge/PowerShell_Coverage-$coveragePercent%25-$color)" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append
          "" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append
          
          # Add per-file coverage table for lib/*.ps1 files
          "### ðŸ“‹ Coverage by File" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append
          "" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append
          "| File | Coverage | Commands | Status |" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append
          "|------|----------|----------|--------|" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append
          
          # Process per-file coverage data
          if ($coverage.AnalyzedFiles -and $coverage.AnalyzedFiles.Count -gt 0) {
            # Group hit and missed commands by file
            $hitCommandsByFile = $coverage.HitCommands | Where-Object { $_.File -like "*lib\*.ps1" } | Group-Object -Property File
            $missedCommandsByFile = $coverage.MissedCommands | Where-Object { $_.File -like "*lib\*.ps1" } | Group-Object -Property File
            
            # Get all analyzed lib/*.ps1 files
            $libFiles = $coverage.AnalyzedFiles | Where-Object { $_ -like "*lib\*.ps1" }
            
            foreach ($file in $libFiles) {
              $fileName = Split-Path -Leaf $file
              
              # Calculate file-specific coverage
              $hitGroup = $hitCommandsByFile | Where-Object { $_.Name -eq $file }
              $missedGroup = $missedCommandsByFile | Where-Object { $_.Name -eq $file }
              
              $hitCommands = if ($hitGroup) { $hitGroup.Count } else { 0 }
              $missedCommands = if ($missedGroup) { $missedGroup.Count } else { 0 }
              $totalCommands = $hitCommands + $missedCommands
              
              if ($totalCommands -eq 0) {
                $filePercent = 0
                $commandsText = "0/0"
              } else {
                $filePercent = [math]::Round(($hitCommands / $totalCommands) * 100, 2)
                $commandsText = "$hitCommands/$totalCommands"
              }
              
              # Determine status emoji based on coverage percentage
              if ($filePercent -ge 80) { $status = "âœ… Good" }
              elseif ($filePercent -ge 60) { $status = "âš ï¸ Fair" }
              else { $status = "âŒ Low" }
              
              "| $fileName | ${filePercent}% | $commandsText | $status |" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append
            }
          } else {
            # Fallback: if no detailed coverage data, list expected lib/*.ps1 files with unknown status
            $libFiles = Get-ChildItem -Path "lib\*.ps1" -File | ForEach-Object { $_.Name }
            foreach ($fileName in $libFiles) {
              "| $fileName | N/A | N/A | â“ No data |" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append
            }
          }
          
          "" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append
        }
        
        # Exit with error code if tests failed
        if ($result.FailedCount -gt 0) {
          Write-Host "âŒ $($result.FailedCount) tests failed" -ForegroundColor Red
          exit 1
        }
        
        Write-Host "âœ… All $($result.PassedCount) PowerShell tests passed on ${{ matrix.os }}" -ForegroundColor Green

    - name: Test PowerShell dry-run functionality
      shell: pwsh
      run: |
        Write-Host "ðŸš€ Testing PowerShell dry-run functionality on ${{ matrix.os }}..." -ForegroundColor Cyan
        
        # Test that PowerShell dry-run works
        .\bin\setup-user.ps1 -DryRun
        
        # Mock hostname for server test to use 'baljeet' which has a packages.yaml
        $env:COMPUTERNAME = "baljeet"
        .\bin\setup-server.ps1 -DryRun
        Write-Host "âœ… PowerShell dry-run tests passed on ${{ matrix.os }}" -ForegroundColor Green

    - name: Upload PowerShell test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: powershell-test-results-${{ matrix.os }}
        path: |
          testresults.xml
          coverage.xml

    - name: Upload PowerShell coverage report
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: powershell-coverage-${{ matrix.os }}
        path: coverage.xml

  test-summary:
    name: Test Summary
    runs-on: ubuntu-latest
    needs: [test-bash, test-powershell]
    if: always()
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts/

    - name: Generate comprehensive test summary
      run: |
        echo "# ðŸ§ª Laingville Test Results Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Platform results
        echo "## ðŸŒ Platform Test Results" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "| Platform | Bash Tests | PowerShell Tests | Status |" >> $GITHUB_STEP_SUMMARY
        echo "|----------|------------|------------------|---------|" >> $GITHUB_STEP_SUMMARY
        
        BASH_STATUS="${{ needs.test-bash.result }}"
        PS_STATUS="${{ needs.test-powershell.result }}"
        
        # Convert status to emoji
        if [ "$BASH_STATUS" = "success" ]; then BASH_EMOJI="âœ…"; else BASH_EMOJI="âŒ"; fi
        if [ "$PS_STATUS" = "success" ]; then PS_EMOJI="âœ…"; else PS_EMOJI="âŒ"; fi
        
        echo "| Nix-on-Ubuntu | $BASH_EMOJI | N/A | $BASH_STATUS |" >> $GITHUB_STEP_SUMMARY
        echo "| Arch Linux | $BASH_EMOJI | N/A | $BASH_STATUS |" >> $GITHUB_STEP_SUMMARY
        echo "| macOS | $BASH_EMOJI | N/A | $BASH_STATUS |" >> $GITHUB_STEP_SUMMARY
        echo "| Windows | N/A | $PS_EMOJI | $PS_STATUS |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Overall status
        if [[ "$BASH_STATUS" == "success" && "$PS_STATUS" == "success" ]]; then
          echo "## ðŸŽ‰ Overall Result: SUCCESS" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "All tests passed across all platforms! ðŸš€" >> $GITHUB_STEP_SUMMARY
          
          # Add test counts if available
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“Š Test Statistics" >> $GITHUB_STEP_SUMMARY
          echo "- **Bash Tests (ShellSpec)**: ~194 examples" >> $GITHUB_STEP_SUMMARY
          echo "- **PowerShell Tests (Pester)**: ~98 tests" >> $GITHUB_STEP_SUMMARY
          echo "- **Total Coverage**: Cross-platform validation" >> $GITHUB_STEP_SUMMARY
          echo "- **Platforms Tested**: Nix-on-Ubuntu, Arch Linux, macOS, Windows" >> $GITHUB_STEP_SUMMARY
          
        else
          echo "## âŒ Overall Result: FAILURE" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Some tests failed. Check the individual job logs for details." >> $GITHUB_STEP_SUMMARY
          exit 1
        fi
        
        # Add coverage summary if artifacts exist
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "## ðŸ“ˆ Coverage Reports" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "Coverage reports have been uploaded as artifacts:" >> $GITHUB_STEP_SUMMARY
        echo "- Bash coverage (Linux only)" >> $GITHUB_STEP_SUMMARY
        echo "- PowerShell coverage (Windows)" >> $GITHUB_STEP_SUMMARY

    # Disabled: XML parsing issues with Pester-generated NUnit format
    # - name: Publish Test Results
    #   uses: dorny/test-reporter@v2
    #   if: always()
    #   with:
    #     name: 'Test Results Summary'
    #     path: 'artifacts/powershell-test-results-*/testresults.xml'
    #     reporter: dotnet-nunit
    #     fail-on-error: 'false'

    # Disabled: Format mismatch - Pester outputs JaCoCo, action expects Cobertura
    # - name: Code Coverage Summary
    #   uses: irongut/CodeCoverageSummary@v1.3.0
    #   if: always()
    #   with:
    #     filename: 'artifacts/powershell-coverage-*/coverage.xml'
    #     badge: true
    #     fail_below_min: false
    #     format: markdown
    #     hide_branch_rate: false
    #     hide_complexity: true
    #     indicators: true
    #     output: both
    #     thresholds: '60 80'

    - name: Add Coverage PR Comment
      uses: marocchino/sticky-pull-request-comment@v2
      if: github.event_name == 'pull_request'
      with:
        recreate: true
        path: code-coverage-results.md