name: Test Laingville Scripts

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

permissions:
  contents: read
  pull-requests: write

jobs:
  test-bash:
    name: Bash Tests
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            platform: nix
            runner: ubuntu-latest
          - os: macos-latest
            platform: macos
            runner: macos-latest
          - os: archlinux
            platform: archlinux
            runner: ubuntu-latest
            container: archlinux:latest
    runs-on: ${{ matrix.runner }}
    container: ${{ matrix.container }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install Nix
      if: matrix.platform == 'nix'
      uses: cachix/install-nix-action@v27
      with:
        nix_path: nixpkgs=channel:nixos-25.05



    - name: Cache tools (Arch Linux)
      if: matrix.platform == 'archlinux'
      id: cache-tools-arch
      uses: actions/cache@v4
      with:
        path: |
          ~/.local/bin/shellspec
          ~/.local/bin/shellcheck
          ~/.local/bin/shfmt
          ~/.local/lib/shellspec
        key: tools-archlinux-shfmt-3.8.0-shellcheck-0.10.0-shellspec-v3

    - name: Cache tools (macOS)
      if: matrix.platform == 'macos'
      id: cache-tools-macos
      uses: actions/cache@v4
      with:
        path: |
          ~/.local/bin/shellspec
          ~/.local/bin/shellcheck
          ~/.local/bin/shfmt
          ~/.local/lib/shellspec
        key: tools-macos-shfmt-3.8.0-shellcheck-0.10.0-shellspec-v2

    - name: Install tools (Nix-on-Ubuntu)
      if: matrix.platform == 'nix'
      run: |
        echo "Installing tools via Nix (no caching, run directly from Nix profile)..."
        # Install tools via Nix
        nix profile install github:NixOS/nixpkgs/nixos-25.05#shellcheck
        nix profile install github:NixOS/nixpkgs/nixos-25.05#shfmt
        nix profile install github:NixOS/nixpkgs/nixos-25.05#shellspec
        nix profile install github:NixOS/nixpkgs/nixos-25.05#kcov
        nix profile install github:NixOS/nixpkgs/nixos-25.05#jq

    - name: Install tools (Arch Linux)
      if: matrix.platform == 'archlinux' && steps.cache-tools-arch.outputs.cache-hit != 'true'
      run: |
        mkdir -p ~/.local/bin
        
        # Update package database and install base tools (skip system upgrade for speed)
        pacman -Sy --noconfirm
        pacman -S --noconfirm base-devel git cmake ninja curl wget tar gzip
        
        # Install shellcheck
        cd /tmp
        wget -qO- https://github.com/koalaman/shellcheck/releases/download/v0.10.0/shellcheck-v0.10.0.linux.x86_64.tar.xz | tar -xJ
        mv shellcheck-v0.10.0/shellcheck ~/.local/bin/
        chmod +x ~/.local/bin/shellcheck
        
        # Install shfmt
        wget -qO ~/.local/bin/shfmt https://github.com/mvdan/sh/releases/download/v3.8.0/shfmt_v3.8.0_linux_amd64
        chmod +x ~/.local/bin/shfmt
        
        # Install shellspec
        curl -fsSL https://git.io/shellspec | sh -s -- --yes

    - name: Install tools (macOS)
      if: matrix.platform == 'macos' && steps.cache-tools-macos.outputs.cache-hit != 'true'
      run: |
        mkdir -p ~/.local/bin
        
        # Install shellcheck
        wget -qO- https://github.com/koalaman/shellcheck/releases/download/v0.10.0/shellcheck-v0.10.0.darwin.x86_64.tar.xz | tar -xJ
        mv shellcheck-v0.10.0/shellcheck ~/.local/bin/
        chmod +x ~/.local/bin/shellcheck
        
        # Install shfmt
        wget -qO ~/.local/bin/shfmt https://github.com/mvdan/sh/releases/download/v3.8.0/shfmt_v3.8.0_darwin_amd64
        chmod +x ~/.local/bin/shfmt
        
        # Install shellspec
        curl -fsSL https://git.io/shellspec | sh -s -- --yes
        
    - name: Install system dependencies (Arch Linux)
      if: matrix.platform == 'archlinux'
      run: |
        # Update package database first
        echo "Updating Arch Linux package database..."
        pacman -Sy --noconfirm

        # Install system packages that aren't cacheable (always run to ensure availability)
        echo "Installing system dependencies for Arch Linux..."
        pacman -S --noconfirm make jq tmux bc wezterm kcov diffutils || {
          echo "kcov package not available, building from source..."
          pacman -S --noconfirm libcurl-gnutls elfutils binutils diffutils
          cd /tmp
          git clone --depth 1 https://github.com/SimonKagstrom/kcov.git
          cd kcov
          mkdir build && cd build
          cmake -G 'Ninja' ..
          ninja
          ninja install
        }

    - name: Install system dependencies (macOS)
      if: matrix.platform == 'macos'
      run: |
        # Install tmux for configuration testing (always install fresh to avoid library issues)
        brew install tmux

    - name: Add tools to PATH
      run: |
        echo "$HOME/.local/bin" >> $GITHUB_PATH
        # Ensure brew-installed tools are in PATH on macOS
        if [ "${{ matrix.platform }}" = "macos" ]; then
          echo "/usr/local/bin" >> $GITHUB_PATH
          echo "/opt/homebrew/bin" >> $GITHUB_PATH
        fi
        # For Nix, add the nix profile bin to PATH
        if [ "${{ matrix.platform }}" = "nix" ]; then
          echo "$HOME/.nix-profile/bin" >> $GITHUB_PATH
        fi
        

    - name: Check formatting and lint
      run: |
        echo "ðŸŽ¨ Checking formatting on ${{ matrix.platform }}..."
        files_to_check=$(find . -type f \( -name "*.sh" -o -name "*.bash" -o -name "*.ps1" \) \
          -not -path "./.git/*" \
          -not -path "./.worktrees/*" \
          -not -path "./dotfiles/*/.*" \
          -not -path "./spec/fixtures/*" \
          2>/dev/null)
        claude_scripts=$(find ./dotfiles/mrdavidlaing/.claude/scripts -type f -name "*.bash" 2>/dev/null || true)
        claude_wrappers=$(find ./dotfiles/mrdavidlaing/.claude/wrappers -type f 2>/dev/null || true)
        all_files="$files_to_check $claude_scripts $claude_wrappers"
        if [ -n "$all_files" ]; then
          ./scripts/format-files.sh --check --batch $all_files
        fi

        echo "ðŸ” Linting bash scripts on ${{ matrix.platform }}..."
        ./scripts/lint-bash.sh
        
    - name: Run shellspec tests with coverage (Linux)
      if: matrix.platform == 'nix' || matrix.platform == 'archlinux'
      shell: bash
      run: |
        echo "ðŸ§ª Running bash tests with coverage on ${{ matrix.platform }}..."
        # Exclude Issue #351 cross-platform test (tested separately)
        regular_specs=$(find spec -name '*_spec.sh' -not -name '*issue-351*' 2>/dev/null || true)

        # Run tests with kcov coverage (skip coverage on Arch Linux if kcov unavailable)
        if command -v kcov >/dev/null 2>&1; then
          echo "Running with kcov coverage..."
          shellspec --shell bash --kcov --covdir coverage \
            --kcov-options "--include-pattern=$(pwd)/lib/" \
            $regular_specs
        else
          echo "âš ï¸ kcov not available, running tests without coverage..."
          shellspec --shell bash $regular_specs
        fi
      
    - name: Run shellspec tests (macOS)
      if: matrix.platform == 'macos'
      shell: bash
      run: |
        echo "ðŸ§ª Running bash tests on ${{ matrix.platform }}..."
        # Exclude Issue #351 cross-platform test (tested separately)
        regular_specs=$(find spec -name '*_spec.sh' -not -name '*issue-351*' 2>/dev/null || true)
        shellspec --shell bash $regular_specs
      
    - name: Upload bash coverage (Linux)
      if: matrix.platform == 'nix' || matrix.platform == 'archlinux'
      uses: actions/upload-artifact@v4
      with:
        name: bash-coverage-${{ matrix.platform }}
        path: coverage/

    - name: Generate bash coverage summary (Linux)
      if: matrix.platform == 'nix' || matrix.platform == 'archlinux'
      run: |
        echo "ðŸ“Š Generating bash coverage summary..."
        # Find the coverage.json file (could be in merged/ or a subdirectory)
        COVERAGE_JSON=$(find coverage -name "coverage.json" -type f | head -1)
        
        if [ -n "$COVERAGE_JSON" ]; then
          # Extract coverage percentage from kcov JSON report
          COVERAGE=$(jq -r .percent_covered "$COVERAGE_JSON")
          
          # Save coverage percentage to file for PR comment
          echo "$COVERAGE" > coverage-bash-${{ matrix.platform }}.txt
          
          echo "Bash Coverage: ${COVERAGE}%" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ“Š **Bash Test Coverage (${{ matrix.platform }})**: ${COVERAGE}%" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Add coverage badge (use shell arithmetic instead of bc)
          if [ "${COVERAGE%.*}" -ge 80 ]; then
            COLOR="brightgreen"
          elif [ "${COVERAGE%.*}" -ge 60 ]; then
            COLOR="yellow"
          else
            COLOR="red"
          fi
          echo "![Coverage](https://img.shields.io/badge/Bash_Coverage-${COVERAGE}%25-${COLOR})" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Add per-file coverage table for lib/*.bash files
          echo "### ðŸ“‹ Coverage by File" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| File | Coverage | Lines | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|------|----------|-------|--------|" >> $GITHUB_STEP_SUMMARY
          
          # Check if files array exists in coverage.json
          if jq -e '.files' "$COVERAGE_JSON" > /dev/null 2>&1; then
            # Parse file coverage data and filter for lib/*.bash files
            jq -r '.files[] | select(.file | test("lib/.*\\.bash$")) | [.file, .percent_covered, (.covered_lines|tostring) + "/" + (.total_lines|tostring)] | @tsv' "$COVERAGE_JSON" | while IFS=$'\t' read -r filepath percent lines; do
              # Extract just the filename from the full path (e.g. /path/to/lib/shared.functions.bash -> shared.functions.bash)
              filename=$(basename "$filepath")
              
              # Determine status emoji based on coverage percentage
              coverage_num=${percent%.*}
              if [ "$coverage_num" -ge 80 ]; then
                status="âœ… Good"
              elif [ "$coverage_num" -ge 60 ]; then
                status="âš ï¸ Fair"
              else
                status="âŒ Low"
              fi
              
              echo "| $filename | ${percent}% | $lines | $status |" >> $GITHUB_STEP_SUMMARY
            done
          else
            # Fallback: if files array doesn't exist, list expected lib/*.bash files with unknown status
            for bashfile in lib/*.bash; do
              if [ -f "$bashfile" ]; then
                display_name=${bashfile#lib/}
                echo "| $display_name | N/A | N/A | â“ No data |" >> $GITHUB_STEP_SUMMARY
              fi
            done
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
        else
          echo "âš ï¸ Coverage JSON file not found" >> $GITHUB_STEP_SUMMARY
        fi

    - name: Upload bash coverage summary
      if: matrix.platform == 'nix' || matrix.platform == 'archlinux'
      uses: actions/upload-artifact@v4
      with:
        name: coverage-summary-bash-${{ matrix.platform }}
        path: coverage-bash-${{ matrix.platform }}.txt
        if-no-files-found: ignore

    - name: Test ShellSpec Issue #351 (WSL boundary bug)
      shell: bash
      continue-on-error: true
      run: |
        echo "ðŸ” Testing ShellSpec Issue #351 on ${{ matrix.platform }}..."
        echo "This test determines if the reporter bug is WSL-specific or affects all platforms."
        echo ""

        # Run the cross-platform test and capture output
        output=$(shellspec spec/shellspec-issue-351-cross-platform_spec.sh 2>&1 || true)
        exit_code=$?

        echo "$output"
        echo ""

        # Check if it's the reporter bug (exit code 1 with "0 failures")
        if [ $exit_code -eq 1 ] && echo "$output" | grep -q "0 failures"; then
          if echo "$output" | grep -q "aborted by an unexpected error"; then
            echo "âŒ **BUG TRIGGERED** on ${{ matrix.platform }}: Reporter crashed despite 0 failures"
            echo "bug_triggered=true" >> issue_351_result.txt
            echo "## âŒ ShellSpec Issue #351: BUG TRIGGERED" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Platform**: ${{ matrix.platform }}" >> $GITHUB_STEP_SUMMARY
            echo "**Result**: Reporter crashed despite 0 test failures" >> $GITHUB_STEP_SUMMARY
            echo "**Exit Code**: $exit_code" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "This platform exhibits the ShellSpec issue #351 reporter bug." >> $GITHUB_STEP_SUMMARY
          else
            echo "âœ… **CLEAN** on ${{ matrix.platform }}: Exit code 1 but no reporter error"
            echo "bug_triggered=false" >> issue_351_result.txt
            echo "## âœ… ShellSpec Issue #351: CLEAN" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Platform**: ${{ matrix.platform }}" >> $GITHUB_STEP_SUMMARY
            echo "**Result**: No reporter bug detected" >> $GITHUB_STEP_SUMMARY
          fi
        elif [ $exit_code -eq 0 ]; then
          echo "âœ… **CLEAN** on ${{ matrix.platform }}: Tests passed normally"
          echo "bug_triggered=false" >> issue_351_result.txt
          echo "## âœ… ShellSpec Issue #351: CLEAN" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Platform**: ${{ matrix.platform }}" >> $GITHUB_STEP_SUMMARY
          echo "**Result**: Tests passed without issues" >> $GITHUB_STEP_SUMMARY
          echo "**Exit Code**: 0" >> $GITHUB_STEP_SUMMARY
        else
          echo "âš ï¸  **UNEXPECTED** on ${{ matrix.platform }}: Unexpected failure (not the reporter bug)"
          echo "bug_triggered=unknown" >> issue_351_result.txt
          echo "## âš ï¸ ShellSpec Issue #351: UNEXPECTED RESULT" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Platform**: ${{ matrix.platform }}" >> $GITHUB_STEP_SUMMARY
          echo "**Result**: Unexpected test failure" >> $GITHUB_STEP_SUMMARY
          echo "**Exit Code**: $exit_code" >> $GITHUB_STEP_SUMMARY
        fi
        echo "" >> $GITHUB_STEP_SUMMARY

    - name: Upload Issue #351 test result
      uses: actions/upload-artifact@v4
      with:
        name: issue-351-result-${{ matrix.platform }}
        path: issue_351_result.txt
        if-no-files-found: ignore

    - name: Test dry-run functionality
      shell: bash
      run: |
        echo "ðŸš€ Testing dry-run functionality on ${{ matrix.platform }}..."
        # Test that dry-run works without requiring sudo/pacman
        export DOTFILES_DIR="./dotfiles/mrdavidlaing"
        ./setup.sh user --dry-run
        
        # Mock hostname command for server test to use 'baljeet' which has packages.yaml
        mkdir -p ~/.local/bin
        echo '#!/bin/bash' > ~/.local/bin/hostname
        echo 'echo "baljeet"' >> ~/.local/bin/hostname
        chmod +x ~/.local/bin/hostname
        export PATH="$HOME/.local/bin:$PATH"
        ./setup.sh server --dry-run
        echo "âœ… Dry-run tests passed on ${{ matrix.platform }}"

  test-powershell:
    name: PowerShell Tests
    strategy:
      matrix:
        os: [windows-latest]
        include:
          # Add specific PowerShell versions if needed
          - os: windows-latest
            powershell-version: "latest"
    runs-on: ${{ matrix.os }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup PowerShell modules
      shell: pwsh
      run: |
        Write-Host "ðŸ”§ Setting up PowerShell environment on ${{ matrix.os }}..." -ForegroundColor Cyan
        
        # Install required modules
        $modules = @('Pester', 'PSScriptAnalyzer')
        foreach ($module in $modules) {
          if (-not (Get-Module -ListAvailable -Name $module)) {
            Write-Host "Installing $module..." -ForegroundColor Yellow
            Install-Module -Name $module -Force -SkipPublisherCheck -Scope CurrentUser
          } else {
            Write-Host "$module already installed" -ForegroundColor Green
          }
        }
        
        # Import modules
        Import-Module Pester -Force
        Import-Module PSScriptAnalyzer -Force

    - name: Run linting
      shell: pwsh
      run: |
        Write-Host "ðŸ” Linting PowerShell scripts on ${{ matrix.os }}..." -ForegroundColor Cyan
        pwsh -NoProfile -ExecutionPolicy Bypass -File scripts/lint-powershell.ps1

    - name: Run Pester tests with coverage
      shell: pwsh
      run: |
        Write-Host "ðŸ§ª Running PowerShell tests with coverage on ${{ matrix.os }}..." -ForegroundColor Cyan
        
        # Configure Pester using the .pester.ps1 file
        $config = Import-PowerShellDataFile '.\.pester.ps1'
        $result = Invoke-Pester -Configuration $config
        
        # Generate coverage summary for GitHub
        if ($result.CodeCoverage) {
          $coverage = $result.CodeCoverage
          $coveragePercent = [math]::Round(($coverage.CoveragePercent), 2)
          
          Write-Host "ðŸ“Š PowerShell Coverage: $coveragePercent%" -ForegroundColor Cyan
          
          # Save coverage percentage to file for PR comment
          $coveragePercent | Out-File -FilePath "coverage-powershell.txt" -Encoding UTF8 -NoNewline
          
          # Add to GitHub Step Summary
          "## ðŸ“Š PowerShell Test Results" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append
          "" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append
          "**Coverage**: $coveragePercent%" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append
          "**Tests Passed**: $($result.PassedCount)" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append
          "**Tests Failed**: $($result.FailedCount)" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append
          "**Tests Skipped**: $($result.SkippedCount)" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append
          "" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append
          "### Coverage Details" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append
          "- **Lines Covered**: $($coverage.NumberOfCommandsExecuted) / $($coverage.NumberOfCommandsAnalyzed)" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append
          "- **Files Analyzed**: $($coverage.AnalyzedFiles.Count)" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append
          "" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append
          "### Coverage Badge" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append
          
          # Determine badge color based on coverage
          if ($coveragePercent -ge 80) { $color = "brightgreen" }
          elseif ($coveragePercent -ge 60) { $color = "yellow" }
          else { $color = "red" }
          
          "![Coverage](https://img.shields.io/badge/PowerShell_Coverage-$coveragePercent%25-$color)" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append
          "" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append
          
          # Add per-file coverage table for lib/*.ps1 files
          "### ðŸ“‹ Coverage by File" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append
          "" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append
          "| File | Coverage | Commands | Status |" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append
          "|------|----------|----------|--------|" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append
          
          # Process per-file coverage data using correct Pester 5+ properties
          # Get all analyzed lib/*.ps1 files
          $libFiles = $coverage.FilesAnalyzed | Where-Object { $_ -like "*lib\*.ps1" }
          
          if ($libFiles -and $libFiles.Count -gt 0) {
            # Group executed and missed commands by file
            $executedCommandsByFile = $coverage.CommandsExecuted | Where-Object { $_.File -like "*lib\*.ps1" } | Group-Object -Property File
            $missedCommandsByFile = $coverage.CommandsMissed | Where-Object { $_.File -like "*lib\*.ps1" } | Group-Object -Property File
            
            foreach ($file in $libFiles) {
              $fileName = Split-Path -Leaf $file
              
              # Calculate file-specific coverage
              $executedGroup = $executedCommandsByFile | Where-Object { $_.Name -eq $file }
              $missedGroup = $missedCommandsByFile | Where-Object { $_.Name -eq $file }
              
              $executedCommands = if ($executedGroup) { $executedGroup.Count } else { 0 }
              $missedCommands = if ($missedGroup) { $missedGroup.Count } else { 0 }
              $totalCommands = $executedCommands + $missedCommands
              
              if ($totalCommands -eq 0) {
                $filePercent = 0
                $commandsText = "0/0"
              } else {
                $filePercent = [math]::Round(($executedCommands / $totalCommands) * 100, 2)
                $commandsText = "$executedCommands/$totalCommands"
              }
              
              # Determine status emoji based on coverage percentage
              if ($filePercent -ge 80) { $status = "âœ… Good" }
              elseif ($filePercent -ge 60) { $status = "âš ï¸ Fair" }
              else { $status = "âŒ Low" }
              
              "| $fileName | ${filePercent}% | $commandsText | $status |" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append
            }
          } else {
            # Fallback: if no detailed coverage data, list expected lib/*.ps1 files with unknown status
            $libFiles = Get-ChildItem -Path "lib\*.ps1" -File | ForEach-Object { $_.Name }
            foreach ($fileName in $libFiles) {
              "| $fileName | N/A | N/A | â“ No data |" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append
            }
          }
          
          "" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append
        }
        
        # Exit with error code if tests failed
        if ($result.FailedCount -gt 0) {
          Write-Host "âŒ $($result.FailedCount) tests failed" -ForegroundColor Red
          exit 1
        }
        
        Write-Host "âœ… All $($result.PassedCount) PowerShell tests passed on ${{ matrix.os }}" -ForegroundColor Green

    - name: Upload PowerShell coverage summary
      uses: actions/upload-artifact@v4
      with:
        name: coverage-summary-powershell
        path: coverage-powershell.txt
        if-no-files-found: ignore

    - name: Test PowerShell dry-run functionality
      shell: pwsh
      run: |
        Write-Host "ðŸš€ Testing PowerShell dry-run functionality on ${{ matrix.os }}..." -ForegroundColor Cyan
        
        # Test that PowerShell dry-run works
        .\bin\setup-user.ps1 -DryRun
        
        # Mock hostname for server test to use 'baljeet' which has a packages.yaml
        $env:COMPUTERNAME = "baljeet"
        .\bin\setup-server.ps1 -DryRun
        Write-Host "âœ… PowerShell dry-run tests passed on ${{ matrix.os }}" -ForegroundColor Green

    - name: Upload PowerShell test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: powershell-test-results-${{ matrix.os }}
        path: |
          testresults.xml
          coverage.xml

    - name: Upload PowerShell coverage report
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: powershell-coverage-${{ matrix.os }}
        path: coverage.xml

  test-summary:
    name: Test Summary
    runs-on: ubuntu-latest
    needs: [test-bash, test-powershell]
    if: always()
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download all artifacts
      uses: actions/download-artifact@v7
      with:
        path: artifacts/

    - name: Generate comprehensive test summary
      run: |
        echo "# ðŸ§ª Laingville Test Results Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Platform results
        echo "## ðŸŒ Platform Test Results" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "| Platform | Bash Tests | PowerShell Tests | Status |" >> $GITHUB_STEP_SUMMARY
        echo "|----------|------------|------------------|---------|" >> $GITHUB_STEP_SUMMARY
        
        BASH_STATUS="${{ needs.test-bash.result }}"
        PS_STATUS="${{ needs.test-powershell.result }}"
        
        # Convert status to emoji
        if [ "$BASH_STATUS" = "success" ]; then BASH_EMOJI="âœ…"; else BASH_EMOJI="âŒ"; fi
        if [ "$PS_STATUS" = "success" ]; then PS_EMOJI="âœ…"; else PS_EMOJI="âŒ"; fi
        
        echo "| Nix-on-Ubuntu | $BASH_EMOJI | N/A | $BASH_STATUS |" >> $GITHUB_STEP_SUMMARY
        echo "| Arch Linux | $BASH_EMOJI | N/A | $BASH_STATUS |" >> $GITHUB_STEP_SUMMARY
        echo "| macOS | $BASH_EMOJI | N/A | $BASH_STATUS |" >> $GITHUB_STEP_SUMMARY
        echo "| Windows | N/A | $PS_EMOJI | $PS_STATUS |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Overall status
        if [[ "$BASH_STATUS" == "success" && "$PS_STATUS" == "success" ]]; then
          echo "## ðŸŽ‰ Overall Result: SUCCESS" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "All tests passed across all platforms! ðŸš€" >> $GITHUB_STEP_SUMMARY
          
          # Add test counts if available
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“Š Test Statistics" >> $GITHUB_STEP_SUMMARY
          echo "- **Bash Tests (ShellSpec)**: ~194 examples" >> $GITHUB_STEP_SUMMARY
          echo "- **PowerShell Tests (Pester)**: ~98 tests" >> $GITHUB_STEP_SUMMARY
          echo "- **Total Coverage**: Cross-platform validation" >> $GITHUB_STEP_SUMMARY
          echo "- **Platforms Tested**: Nix-on-Ubuntu, Arch Linux, macOS, Windows" >> $GITHUB_STEP_SUMMARY
          
        else
          echo "## âŒ Overall Result: FAILURE" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Some tests failed. Check the individual job logs for details." >> $GITHUB_STEP_SUMMARY
          exit 1
        fi
        
        # Add coverage summary if artifacts exist
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "## ðŸ“ˆ Coverage Reports" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "Coverage reports have been uploaded as artifacts:" >> $GITHUB_STEP_SUMMARY
        echo "- Bash coverage (Linux only)" >> $GITHUB_STEP_SUMMARY
        echo "- PowerShell coverage (Windows)" >> $GITHUB_STEP_SUMMARY
        
        # ShellSpec Issue #351 Results
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "## ðŸ› ShellSpec Issue #351 Test Results" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "Testing if the reporter bug is WSL-specific or affects other platforms:" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "| Platform | Bug Triggered | Notes |" >> $GITHUB_STEP_SUMMARY
        echo "|----------|---------------|-------|" >> $GITHUB_STEP_SUMMARY

        for platform in nix archlinux macos; do
          if [ -f "artifacts/issue-351-result-$platform/issue_351_result.txt" ]; then
            result=$(cat "artifacts/issue-351-result-$platform/issue_351_result.txt" | grep "bug_triggered=" | cut -d= -f2)
            if [ "$result" = "true" ]; then
              echo "| $platform | âŒ YES | Reporter crashed despite 0 failures |" >> $GITHUB_STEP_SUMMARY
            elif [ "$result" = "false" ]; then
              echo "| $platform | âœ… NO | Tests passed cleanly |" >> $GITHUB_STEP_SUMMARY
            else
              echo "| $platform | âš ï¸ UNKNOWN | Unexpected result |" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "| $platform | â“ N/A | No result file |" >> $GITHUB_STEP_SUMMARY
          fi
        done

        echo "" >> $GITHUB_STEP_SUMMARY
        echo "_This test calls simple binaries with output redirection to detect the ShellSpec reporter protocol bug._" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY

        # Generate coverage summary for PR comment
        cat > code-coverage-results.md << 'EOF'
        # ðŸ§ª Test Results Summary

        ## ðŸŒ Platform Test Results

        | Platform | Bash Tests | PowerShell Tests | Status |
        |----------|------------|------------------|---------|
        EOF
        
        if [ "$BASH_STATUS" = "success" ]; then
          echo "| Nix-on-Ubuntu | âœ… | N/A | $BASH_STATUS |" >> code-coverage-results.md
          echo "| Arch Linux | âœ… | N/A | $BASH_STATUS |" >> code-coverage-results.md
          echo "| macOS | âœ… | N/A | $BASH_STATUS |" >> code-coverage-results.md
        else
          echo "| Nix-on-Ubuntu | âŒ | N/A | $BASH_STATUS |" >> code-coverage-results.md
          echo "| Arch Linux | âŒ | N/A | $BASH_STATUS |" >> code-coverage-results.md
          echo "| macOS | âŒ | N/A | $BASH_STATUS |" >> code-coverage-results.md
        fi
        
        if [ "$PS_STATUS" = "success" ]; then
          echo "| Windows | N/A | âœ… | $PS_STATUS |" >> code-coverage-results.md
        else
          echo "| Windows | N/A | âŒ | $PS_STATUS |" >> code-coverage-results.md
        fi
        
        # Extract coverage data from artifacts
        echo "" >> code-coverage-results.md
        echo "## ðŸ“ˆ Code Coverage" >> code-coverage-results.md
        echo "" >> code-coverage-results.md
        
        # Read PowerShell coverage if available
        PS_COV="N/A"
        if [ -f "artifacts/coverage-summary-powershell/coverage-powershell.txt" ]; then
          PS_COV=$(cat artifacts/coverage-summary-powershell/coverage-powershell.txt)
          PS_COV="${PS_COV}%"
        fi
        
        # Read Bash coverage (prefer nix, fallback to archlinux)
        BASH_COV="N/A"
        if [ -f "artifacts/coverage-summary-bash-nix/coverage-bash-nix.txt" ]; then
          BASH_COV=$(cat artifacts/coverage-summary-bash-nix/coverage-bash-nix.txt)
          BASH_COV="${BASH_COV}%"
        elif [ -f "artifacts/coverage-summary-bash-archlinux/coverage-bash-archlinux.txt" ]; then
          BASH_COV=$(cat artifacts/coverage-summary-bash-archlinux/coverage-bash-archlinux.txt)
          BASH_COV="${BASH_COV}%"
        fi
        
        echo "| Platform | Coverage |" >> code-coverage-results.md
        echo "|----------|----------|" >> code-coverage-results.md
        echo "| Bash (ShellSpec) | ${BASH_COV} |" >> code-coverage-results.md
        echo "| PowerShell (Pester) | ${PS_COV} |" >> code-coverage-results.md
        echo "" >> code-coverage-results.md
        echo "_Full coverage reports are available as artifacts in the workflow run._" >> code-coverage-results.md
        echo "" >> code-coverage-results.md

        # Add Issue #351 results to PR comment
        echo "## ðŸ› ShellSpec Issue #351 Test Results" >> code-coverage-results.md
        echo "" >> code-coverage-results.md
        echo "Testing if the reporter bug is WSL-specific or affects other platforms:" >> code-coverage-results.md
        echo "" >> code-coverage-results.md
        echo "| Platform | Bug Triggered |" >> code-coverage-results.md
        echo "|----------|---------------|" >> code-coverage-results.md

        for platform in nix archlinux macos; do
          if [ -f "artifacts/issue-351-result-$platform/issue_351_result.txt" ]; then
            result=$(cat "artifacts/issue-351-result-$platform/issue_351_result.txt" | grep "bug_triggered=" | cut -d= -f2)
            if [ "$result" = "true" ]; then
              echo "| $platform | âŒ YES |" >> code-coverage-results.md
            elif [ "$result" = "false" ]; then
              echo "| $platform | âœ… NO |" >> code-coverage-results.md
            else
              echo "| $platform | âš ï¸ UNKNOWN |" >> code-coverage-results.md
            fi
          else
            echo "| $platform | â“ N/A |" >> code-coverage-results.md
          fi
        done

        echo "" >> code-coverage-results.md
        echo "_Known: Bug triggers on WSL when calling Windows .exe binaries. This test determines if it also affects native Linux/macOS._" >> code-coverage-results.md

    # Disabled: XML parsing issues with Pester-generated NUnit format
    # - name: Publish Test Results
    #   uses: dorny/test-reporter@v2
    #   if: always()
    #   with:
    #     name: 'Test Results Summary'
    #     path: 'artifacts/powershell-test-results-*/testresults.xml'
    #     reporter: dotnet-nunit
    #     fail-on-error: 'false'

    # Disabled: Format mismatch - Pester outputs JaCoCo, action expects Cobertura
    # - name: Code Coverage Summary
    #   uses: irongut/CodeCoverageSummary@v1.3.0
    #   if: always()
    #   with:
    #     filename: 'artifacts/powershell-coverage-*/coverage.xml'
    #     badge: true
    #     fail_below_min: false
    #     format: markdown
    #     hide_branch_rate: false
    #     hide_complexity: true
    #     indicators: true
    #     output: both
    #     thresholds: '60 80'

    - name: Add Coverage PR Comment
      uses: marocchino/sticky-pull-request-comment@v2
      if: github.event_name == 'pull_request'
      with:
        recreate: true
        path: code-coverage-results.md